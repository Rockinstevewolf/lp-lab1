# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Баранников С.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|  14.11       |      4-       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Опишите своими словами, чем списки в языке Пролог отличаются от принятых в императивных языках подходов к хранению данных. На какие структуры
данных в традиционных языках похожи списки в Прологе?

Списки в прологе напоминают структуру данных типа Стэк, где мы можем получить только головной элемент списка, после чего, для того чтобы найти остальные элементы списка, двигаемся по хвосту списка.

## Задание 1.3: Предикат обработки списка

`mylen(LIST, LEN)` - LIST=[LIST_HEAD|LIST_TAIL], находит длину LEN, работает посредством рекурсии, отправляясь в саму же себя, передавая переменной функции хвост списка LIST_TAIL, каждый раз отсекая голову LIST_HEAD, пока не встретит конец списка [] и получая 0 значение для увеличения параметра длины при проходе обратно из рекурсии.

`mymember(MEMB, LIST)` - выясняет вхождение одного элемента MEMB в список LIST, работает так же как и mylen(X,Y) по рекурсии, но терминирующим условием же является принадлежность MEMB к голове списка.

`myappend(L1, L2, L)` - слияние списков L1 и L2 и сохранение в L, работает так же по рекурсии, достигая конца L1 и сохраняя L2 в L, чтобы L1 в итоге был лидирующей частью списка L, а при возвращениии из рекурсии каждый раз присваивает голове списка L голову списка L1, то есть поэлементно сохраняя L1 в L после уже сохраненного L2 в L.

`myremove(ELEM, LIST, NEW_LIST)` - удаляет первый подобный элеменет, встретившийся в списке, работает рекурсивно, двигаясь по хвостам списков LIST и и NEW_LIST, пока не встретит ситуацию LIST=[ELEM|TAIL], NEW_LIST=TAIL, после чего сохранит хвост старого списка в новый, а потом поэлементно все элементы списка, кроме ELEM.

`mypermute(L1, L2)` - разделяет список на отдельные составляющие посредством рекурсии, двигаясь по хвосту списка L1.

`mysublist1(L1, L2)` - L1=[L1_H|L1_T], L2=[L2_H|L2_T], проверяет на принадлежность списка L1 к списку L2, сначала рекурсивно двигается по хвосту L2_T, сравнивая головы L1_H и L2_H, после чего в новой рекурсии выполняет те же действия для всех остальных элементов списка L1.

`mysublist2(L1, L2)` - тоже самое, но только с использованием двух раз предиката myappend(L1,L2,L).

Примеры использования:
```prolog
?- mylen([1,2,3,4,5], L).
L = 5.

?- mymember(4,[1,3,6,7,3,4,5,7,4,8]).
true .

?- myappend([1,2,3],[9,5,2,1],L).
L = [1, 2, 3, 9, 5, 2, 1] .

?- myappend([1,2,3],X,[1,2,3,9,6,3,4,6,9]).
X = [9, 6, 3, 4, 6, 9] .

?- myremove(9,[1,3,5,7,9,8,6,4,2,0],L).
L = [1, 3, 5, 7, 8, 6, 4, 2, 0] .

?- mypermute([5,8,2,4],X), mypermute(X,[A,B,C,D]).
X = [5, 8, 2, 4],
A = 5,
B = 8,
C = 2,
D = 4 .

?- mysublist1([1,2,5],[3,8,7,1,2]).
false.

?- mysublist1([1,2,5],[5,8,7,1,2,5]).
Yeah, boi!
true .

?- mysublist1([1,2,5],[5,8,7,1,2,5,3,2,9]).
Yeah, boi!
true .

?- mysublist2([1,2,5],[5,8,7,1,2,5,3,2,9]).
true .
```

Реализация:
```prolog
mylen([], 0).
mylen([_|T], L):- mylen(T, L1), L is L1+1.

mymember(X, [X|_]).
mymember(X, [_|Y]):- mymember(X, Y).

myappend([], L, L).
myappend(X, Y, Z):- X=[H_0|T_1], Z=[H_0|T_2], myappend(T_1, Y, T_2).

myremove(A, [A|TAIL], TAIL).
myremove(A, B, C):- B=[H|TAIL], C=[H|TAIL_WITHOUT_X], myremove(A, TAIL, TAIL_WITHOUT_X).

mypermute([],[]).
mypermute(L, L_SPEC):- L=[X_IN_L|BUFF], mypermute(BUFF, BUFF_SPEC), L_SPEC = [X_IN_L|BUFF_SPEC].

mysublist1(X, _):- X=[], write('Yeah, boi!').
mysublist1(X, Y):- X=[X_HEAD|X_TAIL], Y=[X_HEAD|Y_TAIL], mysublist1(X_TAIL, Y_TAIL).
mysublist1(X, Y):- Y=[_|Y_TAIL], mysublist1(X, Y_TAIL).

mysublist2(X, Y):- myappend(A, _, Y), myappend(_, X, A).

```

Опишите своими словами принцип работы предиката обработки списка.

## Задание 1.4: Предикат обработки списка
Вариант 3. Удаление трех первых элементов списка
Реализация:
```prolog
% С помощью myremove()
del3first1([A|B], Y):- myremove(A, [A|B], [C|D]), myremove(C, [C|D], [E|F]), myremove(E, [E|F], Y).
	
% Без myremove()
del3first2([_|A], Y):- A=[_|B], B=[_|Y].
```
del3first2([_,_,_|A], A)
Примеры использования:
```prolog
?- del3first1([1,2,3,5,6,7,8],X).
X = [5, 6, 7, 8] .

?- del3first2([1,2,3,5,6,7,8],X).
X = [5, 6, 7, 8].
```

## Задание 1.5: Предикат обработки числового списка
Вариант 9. Вычисление числа вхождения 1-го элемента
Реализация:
```prolog
% С помошью mylen() и delete()
inclX(X, LIST, N):- mylen(LIST, N1), delete(LIST, X, SAVE), mylen(SAVE, N2), N is N1-N2.
```

Примеры использования:
```prolog
?- inclX(4,[1,2,4,5,6,7,4,8,9,4,6,8,4],N).
N = 4.
```

## Задание 1.6: Пример совместного использования предикатов, реализованных в пунктах 3 и 4
Реализация:
```prolog
% Удаление только второго и третьего элементов
newfunc(X,C):- X=[A|_], Z=[A], del3first2(X,Y), myappend(Z,Y,C).
```

Примеры использования:
```prolog
?- newfunc([1,2,3,5,6,7,8],X).
X = [1, 5, 6, 7, 8] .
```

## Задание 2: Реляционное представление данных

Опишите, в чем преимущества и недостатки реляционного представления в целом, и конкретного представления, которое вы использовали.

В задании 1 было предложено описать высокоуровневые предикаты обработки списков языка Prolog низкоуровневым методом работы, то есть стандартыми средствами языка, а в задании 2 требуется обработать список утверждений, заданный вариантом (1-4) с помощью удобных предикатов поиска данных языка Prolog


###Опишите принцип реализации всех предикатов, осуществляющих запросы к данным.

findall(+Template, :Goal, -Bag), bagof(+Template, :Goal, -Bag), setof(+Template, +Goal, -Set).

При помощи механизма автоматического перебора можно получить одни за другим все объекты, удовлетворяющие некоторой цели. Всякий раз, как порождается новое решение, предыдущее пропадает и становится с этого момента недоступным. Однако у нас может возникнуть желание получить доступ ко всем порожденным объектам сразу, например собрав их в список.

Итак, данные предикаты посредством задания поиска требуемого элемента +Template, цели, при которой этот элемент достигается :Goal и буфера полученных данных, позволяет нам обработать список заданных по заданию утверждений.

В своем задании я использую только один предикат для запроса findall()/3.

Реализация:
```Prolog
% Task 2: Relational Data

% The line below imports the data
:- ['four.pl'].
% 2. Вариант 2
	% - Напечатать средний балл для каждого предмета

%Сумма списка целых чисел
sumlist([], 0).
sumlist([FIRST|REST], SUM):- sumlist(REST, SUM_REST), SUM is FIRST + SUM_REST.

%Функция создания  утверждений в зависимости от одного предмета в формате subj('Предмет', grade('Имя', Оценка))
make_clauses(_,[]).
make_clauses(X,Y):- Y=[Y_HEAD|Y_TAIL], assert(subj(X, Y_HEAD)), make_clauses(X, Y_TAIL).

%Функция создания  всех утверждений для списка предметов в формате subj('Предмет', grade('Имя', Оценка))
make_subj_clauses([]).
make_subj_clauses(X):- X=[X_HEAD|X_TAIL], findall(A, subject(X_HEAD, A), [GET|_]), make_clauses(X_HEAD, GET), make_subj_clauses(X_TAIL).

%Создание утверждений в формате subj('Предмет', grade('Имя', Оценка))
subj_clauses(X):- findall(A, subject(A, _), X), make_subj_clauses(X).

%Нахождение и печать среднего рейтинга в консоль
avg_rating([]).
avg_rating(X):- X=[X_H|X_T], findall(GRADE, subj(X_H, grade(_,GRADE)), SAVE),length(SAVE,SAVE_LEN),sumlist(SAVE,SAVE_SUM),
	AVG_GRADE is SAVE_SUM/SAVE_LEN, write(X_H), write(' = '), write(AVG_GRADE), nl,
	avg_rating(X_T).

%Итоговая функция:
write_avg_rating():- subj_clauses(X), avg_rating(X), retractall(subj(_,_)).


	% - Для каждой группы, найти количество не сдавших студентов
find_amt_losers([]).
find_amt_losers([GR_H|GR_T]):- findall(NAME, group(GR_H, NAME), BUF), BUF = [NAMES],
	write('Losers of '), write(GR_H), write(' group are:'), nl,
	find_amt_losers_gr(GR_H, NAMES),
		find_amt_losers(GR_T).

find_amt_losers_gr(_, []).
find_amt_losers_gr(GR, [NAM_H|NAM_T]):- findall(NAM_H, subj(SUB, grade(NAM_H, 2)), NAMES), findall(SUB, subj(SUB, grade(NAM_H, 2)), SUBS),
	write_losers(SUBS, NAMES),
	find_amt_losers_gr(GR, NAM_T).
write_losers([], []).
write_losers([S_H|S_T], [L_H|L_T]):- write('		'), write(L_H), write(' ('), write(S_H), write(')'), nl, write_losers(S_T, L_T).
write_all_losers_gr():- subj_clauses(_), findall(A, group(A,_), GROUPS), find_amt_losers(GROUPS), retractall(subj(_,_)).

	% - Найти количество не сдавших студентов для каждого из предметов
find_losers_subj([]).
find_losers_subj([X_HEAD|X_TAIL]):- findall(A, subj(X_HEAD, grade(A,2)), SAVE), length(SAVE, LEN),
	write('	'), write(X_HEAD), write(': '), write(LEN), nl,
	find_losers_subj(X_TAIL).

write_all_losers_subj():- subj_clauses(X), write('Количество двоечников по каждому предмету: '), nl, find_losers_subj(X), retractall(subj(_,_)).

%Общая функция на три пункта и случаи case чтобы посмотреть отдельно:
make_prolog_great_again(1):- write(' 1) Напечатать средний балл для каждого предмета'), nl, write_avg_rating(), nl.
make_prolog_great_again(2):- write(' 2) Для каждой группы, найти количество не сдавших студентов'), nl, write_all_losers_gr(), nl.
make_prolog_great_again(3):- write(' 3) Найти количество не сдавших студентов для каждого из предметов'), nl, write_all_losers_subj(), nl.
make_prolog_great_again():- make_prolog_great_again(1), make_prolog_great_again(2), make_prolog_great_again(3). 
							
```
Примеры использования:
```prolog
?- make_prolog_great_again(1).
 1) Напечатать средний балл для каждого предмета
Логическое программирование = 4.107142857142857
Математический анализ = 4.035714285714286
Функциональное программирование = 4.107142857142857
Информатика = 3.8214285714285716
Английский язык = 4
Психология = 3.857142857142857

true .

?- make_prolog_great_again(2).
 2) Для каждой группы, найти количество не сдавших студентов
Losers of 102 group are:
                Петров (Математический анализ)
                Криптовалютников (Информатика)
                Азурин (Английский язык)
Losers of 101 group are:
                Петровский (Логическое программирование)
                Сидоров (Логическое программирование)
                Безумников (Психология)
Losers of 104 group are:
                Джаво (Логическое программирование)
                Круглосчиталкин (Психология)
Losers of 103 group are:
                Сиплюсплюсов (Информатика)
                Решетников (Английский язык)

true .

?- make_prolog_great_again(3).
 3) Найти количество не сдавших студентов для каждого из предметов
Количество двоечников по каждому предмету:
        Логическое программирование: 3
        Математический анализ: 1
        Функциональное программирование: 0
        Информатика: 2
        Английский язык: 2
        Психология: 2

true .


?- make_prolog_great_again().
 1) Напечатать средний балл для каждого предмета
Логическое программирование = 4.107142857142857
Математический анализ = 4.035714285714286
Функциональное программирование = 4.107142857142857
Информатика = 3.8214285714285716
Английский язык = 4
Психология = 3.857142857142857

 2) Для каждой группы, найти количество не сдавших студентов
Losers of 102 group are:
                Петров (Математический анализ)
                Криптовалютников (Информатика)
                Азурин (Английский язык)
Losers of 101 group are:
                Петровский (Логическое программирование)
                Сидоров (Логическое программирование)
                Безумников (Психология)
Losers of 104 group are:
                Джаво (Логическое программирование)
                Круглосчиталкин (Психология)
Losers of 103 group are:
                Сиплюсплюсов (Информатика)
                Решетников (Английский язык)

 3) Найти количество не сдавших студентов для каждого из предметов
Количество двоечников по каждому предмету:
        Логическое программирование: 3
        Математический анализ: 1
        Функциональное программирование: 0
        Информатика: 2
        Английский язык: 2
        Психология: 2

true .
```

## Выводы

Сформулируйте *содержательные* выводы по лабораторной работе. Чему она вас научила? Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную.


Очень хорошая лабораторная работа. Данное построение задач позволяет в полной мере понять, как работать с метасивмольным программированием и, соответственно, как работает сам Prolog. Стоит заметить, что методы работы с предикатами в Prolog значительно отличаются от методов работы с функциями и процедурами, например, в том же языке C++. Благодаря гибкости метасимволики в Prolog можно получить такие предикаты, где при изменении точек входных данных и выходных при вызове предиката, мы решаем разные задачи с помощью одного лишь предиката. Например, в append(A,B,AandB) можно задать 'A', 'B' и получить 'AandB', или же задать 'A', 'AandB' и получить 'B'. Такие возможности языка сначала ломали мне мозг, но вскоре, после того, как я привык к этому, я начал получать удовольствие от программирования на языке Prolog. Однако, как и везде, есть свои плюсы и минусы, так и в Prolog'e приходится иногда изобретать нечто сложное, чтобы получить что-то простое.
